using System;

namespace QuickSort
{
    class Program
    {
        static void Main()
        {

            //int[] data = new int[] { -1, 25, -58964, 8547, -119, 0, 78596 };
            int n = int.Parse(Console.ReadLine());
            int[] data = new int[n];
            for (int i = 0; i < n; i++)
            {
                data[i] = int.Parse(Console.ReadLine());
            }

            int startIndex = 0;//Винаги започваме от нулевия елемент
            int endIndex = data.Length - 1;//Винаги завършваме със последния елемент
            int top = -1;//индекса на масива в който се пазят индексите на началото и края на разделението
            int[] stack = new int[data.Length];//масива в който се пазят индексите на началото и края на разделението
            //Големината му се определя от факта че неможем да имаме повече от n/2 части с по 1 елемент за начало и 1 за край
            stack[++top] = startIndex;//в първия елемент запазваме началния индекс
            stack[++top] = endIndex;//във втория елемент запазваме последния индекс

            while (top >= 0)//докато сме в обхвата на масива
            {
                endIndex = stack[top--];//тук пазим крайния индекс на разделението
                startIndex = stack[top--];//тук пазим началния индекс на разделението

                int left = startIndex;//започваме от началния индекс на разделението
                int right = endIndex;//завършваме с крайния индекс на разделението
                int x = data[right];//започваме с най-крайния елемент на разделението(с него ще сравняваме останалите)
                int i = (left - 1);//пази индекса на последния разменен елемент минус единица

                for (int j = left; j <= right - 1; ++j)//започваме от началния елемент и въртим до предпоследния елемент
                {
                    if (data[j] <= x)//ако настоящия елемент е по-малък от последния 
                    {//го разменяме с този който е по-голям и сме го прескочили
                        ++i;//пази индекса на последния разменен елемент(по-малък от крайния)
                        int swap = data[i];
                        data[i] = data[j];//в случая j винаги е индекса на настоящото по-малко от x число
                        data[j] = swap;
                    }
                }
                int swapAgain = data[i + 1];//със сигурност знаем че този елемент ще бъде по-голям или равен на крайния
                data[i + 1] = data[right];//затова им разменяме стойностите
                data[right] = swapAgain;

                int p = i + 1;//пази ни индекса където е отишъл крайния елемент

                if (p - 1 > startIndex)//проверяваме дали имаме елементи отляво на поставения току-що краен елемент
                {
                    stack[++top] = startIndex;//приемаме същото начало като предходната итерация
                    stack[++top] = p - 1;//краят обаче вече е елемента преди току-що поставения краен елемент
                }

                if (p + 1 < endIndex)//проверяваме дали имаме елементи отдясно на току-що поставения краен елемент
                {
                    stack[++top] = p + 1;//началото вече е елемента след току-що поставения краен елемент
                    stack[++top] = endIndex;//приемаме същия край като предходната итерация
                }
            }
            foreach (var number in data)
            {
                Console.WriteLine(number);
            }
        }
    }
}
