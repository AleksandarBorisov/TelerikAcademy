using System;

namespace QuickSort
{
    class Program
    {
        static void Main()
        {

            //int[] data = new int[] { -1, 25, -58964, 8547, -119, 0, 78596 };
            int n = int.Parse(Console.ReadLine());
            int[] data = new int[n];
            for (int i = 0; i < n; i++)
            {
                data[i] = int.Parse(Console.ReadLine());
            }

            int startIndex = 0;//Винаги започваме от нулевия елемент
            int endIndex = data.Length - 1;//Винаги завършваме с последния елемент
            int top = -1;//Индекса на масива, в който се пазят индексите на началото и края на разделението
            int[] stack = new int[data.Length];//Масива, в който се пазят индексите на началото и края на разделението
            //Големината му се определя от факта че неможем да имаме повече от n/2 части с по 1 елемент за начало и 1 за край
            stack[++top] = startIndex;//В първия елемент запазваме началния индекс
            stack[++top] = endIndex;//Във втория елемент запазваме последния индекс

            while (top >= 0)//Докато сме в обхвата на масива
            {
                endIndex = stack[top--];//Тук пазим крайния индекс на разделението
                startIndex = stack[top--];//Тук пазим началния индекс на разделението

                int left = startIndex;//Започваме от началния индекс на разделението
                int right = endIndex;//Завършваме с крайния индекс на разделението
                int x = data[right];//Започваме с най-крайния елемент на разделението(с него ще сравняваме останалите)
                int i = (left - 1);//Пази индекса на последния разменен елемент минус единица

                for (int j = left; j <= right - 1; ++j)//Започваме от началния елемент и въртим до предпоследния елемент
                {
                    if (data[j] <= x)//Ако настоящия елемент е по-малък от последния 
                    {//го разменяме с този, който е по-голям и сме го прескочили
                        ++i;//Пази индекса на последния разменен елемент(по-малък от крайния)
                        int swap = data[i];
                        data[i] = data[j];//В случая j винаги е индекса на настоящото по-малко от x число
                        data[j] = swap;
                    }
                }
                int swapAgain = data[i + 1];//Със сигурност знаем, че този елемент ще бъде по-голям или равен на крайния,
                data[i + 1] = data[right];//затова им разменяме стойностите
                data[right] = swapAgain;

                int p = i + 1;//Пази ни индекса, където е отишъл крайния елемент

                if (p - 1 > startIndex)//Проверяваме дали имаме елементи отляво на поставения току-що краен елемент
                {
                    stack[++top] = startIndex;//Приемаме същото начало като предходната итерация
                    stack[++top] = p - 1;//Краят обаче вече е елемента преди току-що поставения краен елемент
                }

                if (p + 1 < endIndex)//Проверяваме дали имаме елементи отдясно на току-що поставения краен елемент
                {
                    stack[++top] = p + 1;//Началото вече е елемента след току-що поставения краен елемент
                    stack[++top] = endIndex;//Приемаме същия край като предходната итерация
                }
            }
            foreach (var number in data)
            {
                Console.WriteLine(number);
            }
        }
    }
}
